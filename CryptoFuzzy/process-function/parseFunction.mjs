import * as espree from "espree";

const arrowRegex = /^(async\s*)?%%%ARGS%%%\s*=>/;
const funcRegex = /^(async\s*)?function(\*|\s|%%%ARGS%%%)/;
const namedMethodRegex = /^(static\s*)?(async\s*)?(set\s*)?(get\s*)?(\*\s*)?[\w$_]+\s*%%%ARGS%%%\s*{/;
const unnamedMethodRegex = /^(static\s*)?(async\s*)?(set\s*)?(get\s*)?(\*)?\s*%%%ARGS%%%\s*{/;

export function parse(func) {
    const fixed = fix(func);

    let tree;
    try {
        tree = espree.parse(fixed.func, {
            range: true,
            ecmaVersion: 5,
            tokens: true,
            ecmaFeatures: {
                jsx: true,
                globalReturn: true,
                impliedStrict: false,
            },
        });
    } catch {
        tree = espree.parse(fixed.func, {
            range: true,
            ecmaVersion: 12,
            tokens: true,
            ecmaFeatures: {
                jsx: true,
                globalReturn: true,
                impliedStrict: false,
            },
        });
    }

    return {tree, tokensSlice: fixed.slice};
}

function fix(func) {
    func = func.replace(/^(async\s*)?(\*\s*)?\[[^\]]*\]/, "");
    const argsReplaced = replaceArgs(func);

	if (arrowRegex.test(argsReplaced) || funcRegex.test(argsReplaced)) {
		return {
			func: `const name = ${func}`,
			slice: [3]
		};
	} else if (namedMethodRegex.test(argsReplaced)) {
        return {
            func: `class Name extends Other { ${func}}`,
            slice: [5, -1]
        };
	} else if (unnamedMethodRegex.test(argsReplaced)) {
        const methodName = /await /.test(argsReplaced)
            ? "async name"
            : /yield[\*\s]/.test(argsReplaced)
                ? "* name"
                : /\Wsuper\s*\(/.test(argsReplaced)
                    ? "constructor"
                    : "name";
        const nameTokens = methodName.includes(" ")
            ? 2
            : 1;
        return {
            func: `class Name extends Other { ${methodName} ${func}}`,
            slice: [5 + nameTokens, -1]
        };
	} else {
		return {
			func,
			slice: [0]
		};
	}
}


function replaceArgs(func) {
    const range = [
        func.indexOf("("),
        func.indexOf("(") + 1,
    ];

    let unclosed = 1;
    while(unclosed && range[1] < func.length) {
        switch(func[range[1]]) {
            case "(":
                unclosed++;
                break;
            case ")":
                unclosed--;
                break;
        }
        range[1] += 1;
    }

    return func.slice(0, range[0]) +
        "%%%ARGS%%%" +
        func.slice(range[1]);
}