import * as espree from "espree";
import { renameConstLet, renameVars } from "./renameVar.mjs";
import { isFunctionNode } from "./utils.mjs";
import { allChildNodes } from "./utils.mjs";

const {Syntax} = espree;

export function refactorTree(root, differentNames = true) {
    const identifiers = getIdentifiers(root);

    let replacers = [];

    for(let i = 1; i <= identifiers.length; i++) {
        const newValue = differentNames
            ? `varName${i}`
            : 'varName';
        for(const identifier of identifiers[i-1]) {
            const token = root.tokens.find(token => token.start === identifier.range[0]);
            token.value = newValue;
        }
    }

    return root.tokens;
}

function getIdentifiers(root) {
    const nodes = allChildNodes(root);
    nodes.push({
        type: Syntax.FunctionExpression,
        value: root,
    });

    const scopeNodes = nodes.filter(hasBlockBody);
    const pureBlockNodes = nodes.filter(node => node.type === Syntax.BlockStatement);

    let renamed = [];
    const ignored = () => renamed.flat();

    // Rename let/const in pure blocks
    for (const block of pureBlockNodes) {
        const newlyRenamed = renameConstLet(block, ignored());
        renamed = renamed.concat(newlyRenamed);
    }

    for (const node of scopeNodes) {
        if (isFunctionNode(node)) {
            renamed = renamed.concat(
                renameVars(node, ignored())
            );
        }
        if (node.type === Syntax.BlockStatement) {
            renamed = renamed.concat(
                renameConstLet(node, ignored())
            );
        } else if (node.body || node.block) {
            renamed = renamed.concat(
                renameVars(node.body || node.block, ignored())
            );
        }
    }

    return renamed;
}

function hasBlockBody(node) {
    return isFunctionNode(node) ||
        [
            Syntax.TryStatement, Syntax.CatchClause, Syntax.WhileStatement, Syntax.IfStatement, Syntax.ForOfStatement, Syntax.ForInStatement, Syntax.ForStatement
        ].includes(node.type);
}