import { join, dirname } from "path";
import { allNodes } from "./utils.js";

function varNamesFromDeclaration(decl) {
    switch(decl.type) {
        case "VariableDeclaration":
            return decl.declarations.flatMap(d => varNamesFromPattern(d.id));
        case "FunctionDeclaration":
        case "ClassDeclaration":
            return decl.id
                ? varNamesFromPattern(decl.id)
                : [];
        default:
            return [];
    }
}

function varNamesFromPattern(pattern) {
    switch(pattern.type) {
        case "Identifier":
            return [{node: pattern, name: pattern.name}];
        case "AssignmentPattern":
            return varNamesFromPattern(pattern.left);
        case "RestElement":
            return varNamesFromPattern(pattern.argument);
        case "ArrayPattern":
            return pattern.elements.filter(Boolean).flatMap(varNamesFromPattern);
        case "ObjectPattern":
            return pattern.properties.flatMap(prop => varNamesFromPattern(prop.value || prop));
        default:
            return [];
    }

}

export function exportNames(root, fileName) {
    const exportDeclarationNames = allNodes(root)
        .filter(n => ['ExportNamedDeclaration'].includes(n.type) && n.declaration)
        .flatMap(n => varNamesFromDeclaration(n.declaration));
    const exportSpecifierNames = allNodes(root)
        .filter(n => ['ExportSpecifier', 'ExportNamespaceSpecifier'].includes(n.type))
        .map(node => ({
            name: node.exported.name || node.exported.value, 
            node, 
            from: node.parent.source?.value
        }));
    const exportDefaultNames = allNodes(root)
        .filter(n => ['ExportDefaultDeclaration'].includes(n.type))
        .map(node => ({
            name: "default",
            node: node.declaration?.id || node.declaration,
            from: node.parent.source?.value
        }));
    const exportAllNames = allNodes(root)
        .filter(n => ['ExportAllDeclaration'].includes(n.type))
        .map(node => ({
            name: "*",
            node,
            from: node.source.value
        }));
    
    const moduleExportsNames = allNodes(root)
        .filter(n => (n.type === "Identifier" && n.name === "exports") ||
            (n.type === "MemberExpression" && n.object.name === "module" && n.property.name === "exports")
        ).flatMap(n => {
            switch(n.parent?.type) {
                case "MemberExpression":
                    return (n.parent.parent?.type === "AssignmentExpression" && n.parent.parent.left === n.parent)
                        ? [{
                            name: n.parent.property?.name,
                            node: n.parent.parent.right,
                        }]
                        : [];
                case "AssignmentExpression":
                    return n.parent.left === n
                        ? [{
                            name: "*",
                            node: n.parent.right
                        },
                        {
                            name: "*",
                            node: n.parent
                        }
                    ]
                        : [];
                default:
                    return [];
            }
        });

    return [
        ...exportDeclarationNames,
        ...exportSpecifierNames,
        ...exportDefaultNames,
        ...exportAllNames,
        ...moduleExportsNames,
    ].map(exp => {
        exp.from = exp.from && join(dirname(fileName), exp.from);
        return exp;
    });
}

export function importNames(root, filename) {
    const importSpecifierNames = allNodes(root)
        .filter(n => ['ImportSpecifier'].includes(n.type))
        .map(node => ({
            from: node.parent.source.value,
            node,
            name: node.imported.name || node.imported
        }));
    const importDefaultSpecifierNames = allNodes(root)
        .filter(n => ['ImportDefaultSpecifier'].includes(n.type))
        .map(node => ({
            from: node.parent.source.value,
            node,
            name: "default"
        }));
    const ImportNamespaceSpecifierNames = allNodes(root)
        .filter(n => ['ImportNamespaceSpecifier'].includes(n.type))
        .map(node => ({
            from: node.parent.source.value,
            node,
            name: "*",
        }));
    const requireNames = allNodes(root)
        .filter(n => n.type === "CallExpression" && n.callee?.name === "require")
        .map(call => ({
            from: call.arguments[0]?.value,
            node: call,
            name: "*"
        }))
        .filter(imp => imp.from);
    
    const exportSpecifierNames = allNodes(root)
        .filter(n => ['ExportSpecifier', 'ExportNamespaceSpecifier'].includes(n.type) && n.parent.source)
        .map(node => ({
            from: node.parent.source.value,
            node,
            name: node.local?.name || node.local?.value || "*"
        }));
    const exportAllNames = allNodes(root)
        .filter(n => ['ExportAllDeclaration'].includes(n.type))
        .map(node => ({
            from: node.source.value,
            node,
            name: "*",
        }));
        
    return [
        ...importSpecifierNames,
        ...importDefaultSpecifierNames,
        ...ImportNamespaceSpecifierNames,

        ...exportSpecifierNames,
        ...exportAllNames,

        ...requireNames,
    ].map(imp => {
        imp.from = join(dirname(filename), imp.from);
        return imp;
    });
}

export function buildDepGraph(files) {
    return Object.fromEntries(Object.entries(files)
        .map(([file, root]) => ([file, {exports: exportNames(root, file), imports: importNames(root, file)}]))
    );
}
