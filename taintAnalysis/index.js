import { mkdir, readdir, readFile, rm } from "fs/promises";
import path, { dirname, join } from "path";
import { fileURLToPath } from "url";
import { start } from "@joernio/astgen";
// import { buildDepGraph } from "./depGraph.js";
import { allNodes, isFunctionNode } from "./utils.js";
import { existsSync, mkdirSync, readFileSync } from "fs";
import lineColumn from "line-column";

const MAX_TAINT_PATH_STR_LENGTH = 4000;
// import { getTaintGraph } from "./taintGraph.js";

// export async function exportToSink(
//     // dir,
//     // name,
//     targetFile,
//     targetStartLine,
//     targetStartCol,
//     targetEndLine,
//     targetEndCol
// ) {
//     // const asts = await loadDir(dir, name);
//     // const depGraph = buildDepGraph(asts);
//     // const fullAst = buildFullAst(asts, depGraph);
//     // const rootExports = findRootExports(fullAst);

//     // const taints = rootExports.map(node => ({
//     //     node,
//     //     by: [],
//     //     kind: "args",
//     //     argIndex: -1,
//     // }));

//     // const taintGraph = getTaintGraph(fullAst, taints);
    
//     const vulnSink = Array.from(taintGraph.keys()).find(node => 
//         node.file === targetFile &&
//         (
//             (node.loc.start?.line === +targetStartLine && node.loc.start?.column === +targetStartCol) ||
//             (node.loc.end?.line === +targetEndLine && node.loc.end?.column === +targetEndCol)
//         )
//     );
//     return vulnSink;
//     console.log("\n\n\n\n\n");

    // if (vulnSink) {
    //     console.log(taintPath(taintGraph.get(vulnSink)[0]));
    // } else {
    //     console.log("Path to the specified sink not found");
    // }
// }


export async function loadDir(dir, name, path = "") {
    const astDir = join(dirname(fileURLToPath(import.meta.url)), "ast", name, path);
    if (!path && !existsSync(astDir)) {
        // try {
        //     await rm(astDir, { force: true, recursive: true});
        // } catch (error) {
        //     console.warn(error);
        // }
        mkdirSync(astDir, {recursive: true});
        await start({
            src: dir,
            output: astDir,
            recurse: true,
        });
    }
    const read = await readdir(astDir, {
        withFileTypes: true
    });
    const files = Object.fromEntries(
        await Promise.all(
            read.filter(f => f.isFile() && f.name.endsWith(".json"))
                .map(f => join(astDir, f.name))
                .map(async f => JSON.parse(await readFile(f, "utf-8")))
                .map(async f => [(await f).fullName, (await f).ast])
        )
    );
    const dirs = read.filter(f => f.isDirectory())
        .map(f => f.name);
    const deeper = await Promise.all(dirs.map(dir => loadDir(dir, name, join(path, dir))));
    return {
        ...files,
        ...deeper.reduce((acc, val) => ({...acc, ...val}), {}),
    };
}


export function buildFullAst(asts, depGraph) {
    Object.entries(asts).forEach(([file, root]) => {
        allNodes(root).forEach(node => node.file = file);
    });
    const allImports = Object.values(depGraph).flatMap(v => v.imports);
    const allExports = Object.values(depGraph).flatMap(v => v.exports);

    Object.values(depGraph)
        .flatMap(file => file.exports)
        .forEach(exp => {
            exp.node.isExport = true;
            exp.node.importedBy = allImports
                .filter(imp => imp.from === exp.node.file && (
                    imp.name === "*" || imp.name === exp.name
                )).map(imp => imp.node);
        });
    Object.values(depGraph)
        .flatMap(file => file.imports)
        .forEach(imp => {
            imp.node.isImport = true;
            imp.node.from = imp.from;
            imp.node.imports = allExports
                .filter(exp => exp.node.file === imp.from && (
                    imp.name === "*" || imp.name === exp.name
                )).map(exp => exp.node);
        });
    
    return {
        type: "Project",
        files: Object.values(asts),
    };
}

export function findRootExports(fullAst) {
    return allNodes(fullAst)
        .filter(node => node.isExport && !node.importedBy.length);
}

export function buildTaintPath(taint, visited=[taint]) {
    if (taint.by?.length && !taint.rootTaint) {
        const notVisited = taint.by.filter(t => !visited.includes(t));
        let path;
        notVisited.forEach(parent => {
            if (path) return;
            path = buildTaintPath(parent, visited.concat([parent]));
        });
        return path && path.concat([taint]);
    } else {
        return [taint];
    }
}

export function taintPath(taint, repoUrl) {
    const pathTaints = buildTaintPath(taint);

    const firstArgNode = pathTaints.slice(1, -1)
        .find(({node}) => node.type === "Identifier" && isFunctionNode(node.parent));

    const pathString = [
        pathTaints[0],
        firstArgNode,
        pathTaints.at(-1)
    ].filter(Boolean).map(({node}) => {
        const lineCol = lineColumn(readFileSync(node.file, "utf-8"))
            .fromIndex(node.start);
        const fileUrl = join(repoUrl, node.file.split("/").slice(3).join("/"));
        let loc = `${fileUrl}#L${lineCol.line}`;
        return {"name": node.name || false, "link": loc};

    });

    // pathTaints.map(({node}, i)=>{

    //     if (i === 0 ||  // top-level export
    //         (node.type === "Identifier" && isFunctionNode(node.parent)) ||  // argument to function, may be introduced by an attacker
    //         i === pathTaints.length - 1) 
    //     {      // vulnerable sink
    //             const lineCol = lineColumn(readFileSync(node.file, "utf-8"))
    //             .fromIndex(node.start);
    //             const fileUrl = join(repoUrl, node.file.split("/").slice(3).join("/"));
    //             let loc = `${fileUrl}#L${lineCol.line}`;
    //             pathString.push({"name": node.name || false, "link": loc})

    //     }
    // })

    return pathString;  
}

    // if (isFunctionNode(node)) {
    //     return `function ${node.id?.name}@${loc}`
    // } else if (node.type === "Identifier") {
    //     return `${isFunctionNode(node.parent) ? "arg " : ""}${node.name}@${loc}`;
    // } else {
    //     return `${loc}`;
    // }



    // return pathTaints.length < MAX_TAINT_PATH_STR_LENGTH
    //     ? pathTaints.map(taint => taintToString(taint, repoUrl))
    //     : `Path too long: over ${MAX_TAINT_PATH_STR_LENGTH} nodes`;

// export function taintPath(taint) {
//     const pathNodes = [taint.node];
//     // let path = nodeToString(taint.node);
//     let t = taint;
//     while(t.by[0]) {
//         t = t.by[0];
//         pathNodes.unshift(t.node);
//     }
//     return pathNodes.length < MAX_TAINT_PATH_STR_LENGTH
//         ? pathNodes.map(node => nodeToString(node)).join(" --> ")
//         : `Path too long: over ${MAX_TAINT_PATH_STR_LENGTH} nodes`;
// }

// function taintToString({node, type}, repoUrl) {
//     const lineCol = lineColumn(readFileSync(node.file, "utf-8"))
//         .fromIndex(node.start);
//     const fileUrl = join(repoUrl, node.file.split("/").slice(3).join("/"));
//     let loc = `${fileUrl}#L${lineCol.line}`;
    // let loc = `${node.file}:${locToString(node.loc?.start)}`;
    // let loc = `${node.file}:${node.start}`;



    // if (isFunctionNode(node)) {
    //     return `function ${node.id?.name}@${loc}`
    // } else if (node.type === "Identifier") {
    //     return `${isFunctionNode(node.parent) ? "arg " : ""}${node.name}@${loc}`;
    // } else {
    //     return `${loc}`;
    // }
// }

// function locToString(loc) {
//     return `${loc?.line || "?"}:${loc?.column || "?"}`;
// }

// const [
//     dir,
//     targetFile,
//     targetStartLine,
//     targetStartCol,
//     targetEndLine,
//     targetEndCol
// ] = process.argv.slice(2);

// analyze(
//     dir,
//     dir,
//     targetFile,
//     targetStartLine,
//     targetStartCol,
//     targetEndLine,
//     targetEndCol,
// );