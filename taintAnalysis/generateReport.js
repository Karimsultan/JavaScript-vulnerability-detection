import fs from "fs";
import path from 'path';
import { fileURLToPath } from 'url';

const lastIndex = 0;

export function generateReport(funcObj) {

    const reports = [];

    for(let i = 0; i < funcObj.reachableSinkPaths.length; i++){
        const vulnType = funcObj.protoPollution
            ? "Prototype Pollution"
            : funcObj.redos
                ? "ReDoS"
                : "";
        
        const packageName = funcObj.fileLink.split("/")[4]; 
        const evilRegexPresence = funcObj.evilRe 
            ? `4. The evil regex ${funcObj.evilRe.length == 1 ? "is" : "are"} : ${funcObj.evilRe.join(";")}`
            : "";


        reports.push( `${vulnType} vulnerability in ${packageName} npm package.
        1. Vulnerable functionality is exported here: ${funcObj.reachableSinkPaths[i][0].link}.
        2. Vulnerable value can be introduced by an attacker here: ${funcObj.reachableSinkPaths[i][1].link}.
        3. The malicious argument flows into a vulnerable sink here: ${funcObj.reachableSinkPaths[i].at(-1).link} in "${funcObj.reachableSinkPaths[i].at(-1).name}" variable.
        ${evilRegexPresence}`);
    }

    return reports.join("\n\n----------------------------------\n\n");


}

function isCLI() {
    const nodePath = path.resolve(process.argv[1]);
    const modulePath = path.resolve(fileURLToPath(import.meta.url));
    return nodePath === modulePath;
}

if (isCLI()) {
    const text = "[" + fs.readFileSync(process.argv[2]).toString().split("\n").filter(Boolean).join(",") + "]";
    const db = JSON.parse(text).slice(lastIndex);
    
    db.forEach((fullFuncObj,i) => {
        if(i % 50 == 0){
            console.log("processed: " + i)
        }
        if(fullFuncObj.reachableSinkPaths.length){
        fs.appendFileSync(process.argv[3], generateReport(fullFuncObj) + "\n\n----------------------------------\n\n");
        }
    })
   
}
