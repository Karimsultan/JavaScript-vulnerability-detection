export function getStandaloneIdentifiers(node) {
    const ids = allChildNodes(node)
        .flatMap(standaloneIds);
    return ids
}


export function hasBlockBody(node) {
    return isFunctionNode(node) ||
        [
            "TryStatement", "CatchClause", "DoExpression", "WhileStatement", "IfStatement", "ForOfStatement", "ForInStatement", "ForStatement", "File", "Program"
        ].includes(node.type);
}

function standaloneIds(node) {
    const possibleIds = [];
    switch (node.type) {
        case "RestElement":
        case "SpreadElement":
        case "UpdateExpression":
        case "AwaitExpression":
        case "UnaryExpression":
        case "YieldExpression":
        case "ReturnStatement":
            possibleIds.push(node.argument);
            break;
        case "AssignmentPattern":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "LogicalExpression":
        case "ForInStatement":
        case "ForOfStatement":
        case "ThrowStatement":
            possibleIds.push(node.left, node.right);
            break;
        case "ConditionalExpression":
            possibleIds.push(node.test, node.consequent, node.alternate);
            break;
        case "DoWhileStatement":
        case "IfStatement":
        case "SwitchCase":
        case "WhileStatement":
            possibleIds.push(node.test);
            break;
        case "ForStatement":
            possibleIds.push(node.init, node.test, node.update);
            break;
        case "ExportSpecifier":
            possibleIds.push(node.local);
            break;
        case "ExportDefaultDeclaration":
            possibleIds.push(node.declaration);
            break;
        case "ObjectProperty":
        case "ObjectMethod":
            possibleIds.push(node.value, node.id?.name);
            break;
        case "ArrowFunctionExpression":
            possibleIds.push(node.body);
            break;
        case "TaggedTemplateExpression":
            possibleIds.push(node.tag);
            break;
        case "ExpressionStatement":
            possibleIds.push(node.expression);
            break;
        case "TemplateLiteral":
        case "SequenceExpression":
            possibleIds.push(...node.expressions);
            break;
        case "CallExpression":
        case "NewExpression":
            possibleIds.push(node.callee, ...node.arguments);
            break;
        case "SwitchStatement":
            possibleIds.push(node.discriminant);
            break;
        case "VariableDeclarator":
            possibleIds.push(node.init);
            break;
        case "WithStatement":
            possibleIds.push(node.object);
            break;
        case "ArrayPattern":
        case "ArrayExpression":
            possibleIds.push(...node.elements);
            break;
        case "MemberExpression":
            possibleIds.push(node.object);
            if (node.computed) {
                possibleIds.push(node.property);
            }
            break;
    }
    return possibleIds
        .filter(node => node?.type === "Identifier");
}

export function memo(func) {
    const resultsMap = new WeakMap();
    return arg => resultsMap.get(arg) || resultsMap.set(arg, func(arg)).get(arg);
    // return func;
}
export function asyncMemo(func) {
    const resultsMap = new WeakMap();
    return async arg => resultsMap.get(arg) || resultsMap.set(arg, await func(arg)).get(arg);
}

export const allNodes = memo((root) => [root, ...allChildNodes(root)]);

export const allChildNodes = memo((root) => {
    let currentLevel = [root];
    let collectedNodes = [];
    while(currentLevel.length) {
        currentLevel = getChildNodes(currentLevel);
        collectedNodes = currentLevel.concat(collectedNodes);
    }
    return collectedNodes;
})

function getChildNodes(parents) {
    return parents
        .filter(Boolean)
        .flatMap((parent) => Object.entries(parent)
            .filter(([key, value]) => !['parent', 'importedBy', 'imports'].includes(key))
            .flatMap(([key, value]) => Array.isArray(value)
                ? value
                : [value]
            )
            .filter(value => value?.type)
            .map(value => {
                value.parent = parent;
                return value;
            })
        );
}

export function isFunctionNode(node) {
    return [ "FunctionExpression", "ArrowFunctionExpression", "FunctionDeclaration", "ClassMethod" ]
        .includes(node?.type);
}

export function isImportNode(node) {
    return [ 
        "ImportAttribute","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier"
     ]
        .includes(node?.type);
}

export function isExportNode(node) {
    return [ "ExportAllDeclaration","ExportDefaultDeclaration","ExportDefaultSpecifier","ExportNamedDeclaration","ExportNamespaceSpecifier","ExportSpecifier" ]
        .includes(node?.type);
}

export function closestParent(node, predicate = () => true) {
    return node?.parent
        ? predicate(node.parent)
            ? node.parent
            : closestParent(node.parent, predicate)
        : null;
}
