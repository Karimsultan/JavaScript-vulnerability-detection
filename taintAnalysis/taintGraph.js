import { getIdentifiers } from "./renameVar.js";
import { closestParent, isFunctionNode } from "./utils.js";
import path from "path";

function taintId(id, by, kind = by[0].kind) {
    // Id can be a pattern
    switch (id?.type) {
        case "Identifier":
            return [{node: id, kind, by}];
        case "ObjectPattern":
            return id.properties.flatMap(p => taintId(p.value, by, kind));
        case "ArrayPattern":
            return id.elements.flatMap(e => taintId(e, by, kind));
        case "AssignmentPattern":
            return taintId(id.left, by, kind);
        default:
            return [];
    }
}

function taintAssignment(node, by, kind = by.kind) {
    // This is supposed to taint expressions, patterns etc when something's assigned to them
    switch(node?.type) {
        case "RestElement":
            return taintAssignment(node.argument, by, kind);
        case "VariableDeclaration":
            return node.declarations
                .map(d => d.id || d)
                .flatMap(id => taintId(id, by, kind));
        case "ThisExpression":
            // Not dealing with classes for now; This shoud return-taint the class I guess
            return [];
        case "ArrayExpression":
            return node.elements
                .map(e => taintAssignment(e, by, kind));
        case "ObjectExpression":
            return node.properties
                .flatMap(p => taintAssignment(p.value, by, kind));
        case "FunctionExpression":
            return taintAssignment(node.id, by, kind);
        case "UpdateExpression":
            return taintAssignment(node.argument, by, kind);
        case "AssignmentExpression":
            return taintAssignment(node.left, by, kind);
        case "MemberExpression":
        case "OptionalMemberExpression":
            return taintAssignment(node.object, by, kind);
        case "ParenthesizedExpression":
            return taintAssignment(node.expression, by, kind);
        default: 
            return taintId(node, by, kind);
    }
}

function taintArguments(callee, by, argIndex, allIds) {
    if (isFunctionNode(callee)) {
        const args = argIndex < 0
                ? callee.params
                : [
                    callee.params[argIndex] ||
                    callee.params.slice(-1)[0]?.argument // RestElement
                ];
        return args.filter(Boolean)
            .flatMap(arg => taintAssignment(arg, by, 'value'));
    } else if (callee.isImport) {
        return callee.imports.map(node => ({
            node,
            by,
            kind: "args",
            argIndex
        }));
    } else if(callee.type === "CallExpression") {
        return callee.arguments.map(arg => ({
            node: arg,
            by,
            kind: "args",
            argIndex: -1,
        }));
    } else if (callee.type === "Identifier") {
        switch(callee.parent.type) {
            case "VariableDeclarator":
            case "AssignmentExpression":
                return (callee.parent.id || callee.parent.left) === callee
                    ? [{
                        node: (callee.parent.init || callee.parent.right),
                        by,
                        kind: "args",
                        argIndex,
                    }].filter(t => t.node)
                    : [];
            case "ImportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ExportSpecifier":
            case "FunctionDeclaration":
            default:
                return [{
                    node: callee.parent,
                    by,
                    kind: "args",
                    argIndex
                }];
        }
    } else {
        return [];
    }
}

function taintValue(taint) {
    let newTaints = [];
    switch(taint.node.parent.type) {
        case "ArrayExpression":
        case "AwaitExpression":
        case "BinaryExpression":
        case "BindExpression":
        case "LabeledStatement":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "PrivateName":
        case "ObjectMethod":
        case "ObjectPattern":
        case "ObjectProperty":
        case "ObjectExpression":
        case "ParenthesizedExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "LogicalExpression":
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "MetaProperty":
        case "ArrayPattern":
        case "SpreadElement":
        case "ConditionalExpression":
        // Export taints are done separately
        case "ExportDefaultDeclaration":
        case "ExportDefaultSpecifier":
        case "ExportNamedDeclaration":
        case "ExportNamespaceSpecifier":
        case "ExportSpecifier":
            newTaints = [{
                node: taint.node.parent,
                by: [taint],
                kind: taint.kind
            }];
            break;
        case "SequenceExpression":
            newTaints = taint.node.parent.expressions.slice(-1)[0] === taint.node
                ? [{
                    node: taint.node.parent,
                    by: [taint],
                    kind: taint.kind
                }]
                : [];
            break;
        case "VariableDeclarator":
            newTaints = taint.node === taint.node.parent.init
                ? [{
                    node: taint.node.parent.id,
                    by: [taint],
                    kind: taint.kind
                }]
                : [];
            break;
        case "ReturnStatement":
        case "YieldExpression":
            const closestFunc = closestParent(taint.node.parent, isFunctionNode);
            newTaints = [
                {
                    node: closestFunc,
                    by: [taint],
                    kind: taint.kind
                },
                {
                    node: closestFunc?.id,
                    by: [taint],
                    kind: taint.kind
                }
            ].filter(t => t.node);
            break;
        case "ForInStatement":
        case "ForOfStatement":
        case "AssignmentPattern":
        case "AssignmentExpression":
            newTaints = taint.node.parent.left === taint.node
                ? []
                : taintAssignment(taint.node.parent.left, [taint]);
            break;
        case "CallExpression":
        case "OptionalCallExpression":
            newTaints = taint.node.parent.callee === taint.node
                ? [
                    {
                        node: taint.node.parent,
                        by: [taint],
                        kind: taint.kind
                    },
                    // taintedArray.forEach(...)
                    ...taint.node.parent.arguments.map(arg => ({
                        node: arg,
                        by: [taint],
                        kind: "args",
                        argIndex: -1,
                    })),
                ]
                : [
                    {
                        node: taint.node.parent.callee,
                        by: [taint],
                        kind: "args",
                        argIndex: taint.node.parent.arguments.indexOf(taint.node),
                    },
                    {
                        node: taint.node.parent,
                        by: [taint],
                        kind: taint.kind,
                    }
                ];
            break;

        // Only args taints are propagated into imports
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        
        // This is too new to handle in POC
        case "ModuleExpression":
        case "Decorator":
        case "TopicReference":
        case "StaticBlock":
        case "RecordExpression":
        case "TupleExpression":

        // Not dealing with try/catch yet
        case "ThrowStatement":
        case "TryStatement":
        case "CatchClause":
        

        // Not dealing with classes yet
        case "NewExpression":
        case "Super":
        case "ClassBody":
        case "ClassDeclaration":
        case "ClassExpression":
        case "ClassImplements":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ClassPrivateProperty":
        case "ClassProperty":
        
        // ???
        case "Variance":
        case "ForStatement":

        default:
            newTaints = [];
    };

    // Handle exports
    if (taint.node.isExport) {
        newTaints = newTaints.concat(taint.node.importedBy.map(node => ({
            node,
            by: [taint],
            kind: "value"
        })));
    }

    return newTaints;
}

export function getTaintGraph(root, taintedLeaves, acc = new Map()) {
    const allIds = getIdentifiers(root);
    const taints = taintedLeaves
        .flatMap(leaf => {
            const spread = allIds.find(group => group.includes(leaf.node))
                ?.map(node => ({
                    ...leaf,
                    node,
                    by: [leaf]
                }));
            return [leaf, ...(spread || [])];
        });
    addTaints(acc, taints);
        
    const newLeaves = taints.flatMap((taint) => {
        switch(taint.kind) {
            case "args":
                return [
                    ...taintArguments(taint.node, [taint], taint.argIndex, allIds),
                    ...taintValue(taint),
                ];
            case "value":
            default:
                return taintValue(taint);
        }
    });

    const newAdded = addTaints(acc, newLeaves);
    if (!newAdded.length) {
        return acc;
    }
    
    return getTaintGraph(root, newAdded, acc);
}

function addTaints(to, taints) {
    const added = [];
    taints.forEach(taint => {
        const taints = to.get(taint.node) || [];
        const existing = taints.find(t => t.kind === taint.kind && t.argIndex === taint.argIndex);
        if (existing) {
            existing.by = existing.by.concat(taint.by);
        } else {
            taints.push(taint);
            to.set(taint.node, taints);
            added.push(taint);
        }
    });
    return added;
}

function relativePath(node, value) {
    return value && path.join(path.dirname(node.file), value);
}