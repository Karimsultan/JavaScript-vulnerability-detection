import { allChildNodes, getStandaloneIdentifiers, hasBlockBody, isFunctionNode, memo } from "./utils.js";

export const getIdentifiers = memo((root) => {
    const nodes = allChildNodes(root);

    const scopeNodes = nodes.filter(hasBlockBody);
    const scopeLength = scopeNodes.length;
    const pureBlockNodes = nodes.filter(node => node.type === "BlockStatement");
    const pureBlockLength = pureBlockNodes.length;

    let renamed = [];
    const ignored = () => renamed.flat();

    // Rename let/const in pure blocks
    // Not using for of for performace
    for (let i = 0; i < pureBlockLength; i++) {
        renameConstLet(pureBlockNodes[i], ignored()).forEach(vars => renamed.push(vars));
    }

    for (let i = 0; i < scopeLength; i++) {
        renameVars(scopeNodes[i], ignored()).forEach(vars => renamed.push(vars));
    }

    return renamed;
});

// This function does not recurse on its own
function renameVars(functionBodyNode, ignoreIds = []) {
    const declared = getVarDeclaredIds(functionBodyNode)
        .concat(getParamIds(functionBodyNode))
        .filter(id => !ignoreIds.includes(id));
    const standalone = getStandaloneIdentifiers(functionBodyNode);
    const result = declared.map(decl => {
        const matching = standalone.filter(id => id.name === decl.name);
        matching.push(decl);
        return matching;
    });
    return result;
}

// This function does not recurse on its own
function renameConstLet(blockNode, ignoreIds = []) {
    const declared = getConstDeclaredIds(blockNode)
        .filter(id => !ignoreIds.includes(id));
    const standalone = getStandaloneIdentifiers(blockNode)
        .filter(id => !ignoreIds.includes(id));
    const result = declared.map(decl => {
        const matching = standalone.filter(id => id.name === decl.name);
        matching.push(decl);
        return matching;
    });
    return result;
}

function getVarDeclaredIds(node) {
    const children = allChildNodes(node);
    const ids = children
        .filter(child => (child.type === "VariableDeclarator" && child.parent?.kind === "var") || child.type === "FunctionDeclaration")
        // .concat(children.filter(child => child.type === "FunctionDeclaration"))
        .map(decl => decl?.id)
        .filter(Boolean);
    return ids;
}

const IMPORT_DECL_TYPES = [
    "ImportDefaultSpecifier",
    "ImportNamespaceSpecifier",
    "ImportSpecifier"
];

function getConstDeclaredIds(node) {
    const children = allChildNodes(node);
    const constLetDeclarators = children
        .filter(child => child.type === "VariableDeclarator" && child.parent?.kind !== "var")
        .map(decl => decl.id);
    const imports = children
        .filter(child => IMPORT_DECL_TYPES.includes(child.type))
        .map(spec => spec.local);
    return constLetDeclarators
        .concat(imports)
        .filter(Boolean);
}

function getParamIds(node) {
    return (node.params || [])
        .map(param => {
            switch (param.type) {
                case "RestElement":
                    return param.argument;
                default:
                    return param.left || param;
            }
        })
        .filter(param => param.type === "Identifier");
}