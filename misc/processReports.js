import fs from "fs";
import fetch from "node-fetch";


// input - taintResultsReports.txt
const data = fs.readFileSync(process.argv[2]).toString().split("----------------------------------").slice(0,-1);

console.log(data.length);
console.log(data[0]);

const jsonData = data.map((report, i) =>{
    console.log(i);
    report = report.trim();

    const type = report.includes("Prototype Pollution") ? "Prototype Pollution" :
                    report.includes("ReDoS") ? "ReDoS" : "";

    const regex = report.match(/4\. The evil regex (is|are) : (.*)/)?.[2];

    const vendor_Package = report.match(/is exported here: (.*)\./)[1].split("/").slice(2,4).join("/");

    const varName = report.match(/ in "(.*)" variable/)[1];

 // if there is object with the same type, vendor and varName - skip.
 // if there is object with the same type vendor and regex - skip.

 //question - how does it know not to include regex prop if there is none

    return {"original": report, 
            "type": type,
            "regex": regex,
            "vendor_Package": vendor_Package,
            "varName": varName
}

});

const filtered = jsonData.reduce((acc, curr, i) => {
    const exists = acc.some(existing => ["vendor_Package", "type", "varName", "regex"]
        .every(key => existing[key] === curr[key])
    );
    if (!exists && !["i", "index", "_idx", "idx", "false"].includes(curr.varName)) {
        acc.push(curr);
    }
    return acc;
}, []);

await Promise.all(filtered.map(entry => checkforDups(entry)));

console.log(filtered[0]);

console.log(filtered.length);

fs.writeFileSync(process.argv[3], JSON.stringify(filtered, null, 4)); 


async function checkforDups(report) {
    // let foundEntries = [];
    const CWEs = report.type === "Prototype Pollution"
        ? ["CWE-1321", "CWE-915", "CWE-471"]
        : report.type === "ReDoS"
            ? ["CWE-1333", "CWE-185", "CWE-407"]
            : [];
    try {
        const res = await fetch(`https://cvepremium.circl.lu/api/search/${report.vendor_Package}`)
            .then(result => result.json());
        report.possibleDuplicate = res.results
            .filter(entry => CWEs.includes(entry.cwe))
            .map(entry => entry.id);
    } catch(error) {
        console.error(error);
        report.possibleDuplicate = [];
    }
    
}



